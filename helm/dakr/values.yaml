nameOverride: ""
fullnameOverride: ""

# The cloud provider where the operator is being deployed.
# Must be one of: "aws", "gcp", "azure", or "" (for no cloud provider).
cloud: ""

image:
  repository: docker.io/devzeroinc
  # This sets the pull policy for images.
  pullPolicy: Always 
  # Overrides the image tag whose default is the chart appVersion.
  tag: "v0.0.32"

imagePullSecrets: []

operator:
  enabled: true
  image: dakr-operator
  replicas: 3
  resources:
    requests:
      cpu: 10m
      memory: 64Mi
  endpoint: "https://dakr.devzero.io"
  logLevel: "info"
  clusterToken: "REPLACE_WITH_TOKEN" # If this is empty, the operator will attempt to read from the ConfigMap below.
                   # If set to a non-empty string, this value will be used directly.
  clusterName: "REPLACE_WITH_CLUSTER_NAME" # If this is empty, the operator will attempt to read from the ConfigMap below.
                  # If set to a non-empty string, this value will be used directly.
  clusterLocation: "REPLACE_WITH_CLUSTER_LOCATION"  # usually the cloud region code for where the cluster is running, can also be the zone if the cluster is zonal
  # noCloudCreds: true # If true, operator will not attempt to perform node scaling operations, and will not require cloud credentials
  # tokenFromConfigMap: # If clusterToken is not specified above, operator will read from below ConfigMap value
  #   name: "devzero-zxporter-env-config" # Name of the ConfigMap
  #   namespace: "devzero-zxporter"       # Namespace of the ConfigMap
  #   key: "CLUSTER_TOKEN"                # Key in the ConfigMap's data to get the token
  # nameFromConfigMap: # If clusterName is not specified above, operator will read from below ConfigMap value
  #   name: "devzero-zxporter-env-config" # Name of the ConfigMap
  #   namespace: "devzero-zxporter"       # Namespace of the ConfigMap
  #   key: "KUBE_CONTEXT_NAME"            # Key in the ConfigMap's data to get the cluster name from
  customScheduler: false
  port: 9443
  debugPort: 8082
  features:
    argocdPatching: false # if set, the operator will patch argo applications to ignore differences from the dakr operator
    workloadRecBatchSize: 1 # needs to be >=1; determines batch size of pulling down workload recommendations from control plane, before being persisted as CRDs 
    nodeGroupRecBatchSize: 1 # needs to be >=1; determines batch size of pulling down node group recommendations from control plane, before being persisted as CRDs
  # Runtime directories to include in live migration checkpoint operations
  # These directories will be passed to the live migration service for CRIU checkpoint operations
  runtimeDirs: []
  serviceAccount:
    name: "dakr-operator-sa"
    # Annotations for cloud provider IAM integration.
    #
    # For AWS EKS with IAM Roles for Service Accounts (IRSA):
    # 1. Run the terraform module in terraform/aws/.
    # 2. Set the annotation key to the output 'ksa_annotation_key_aws' (eks.amazonaws.com/role-arn).
    # 3. Set the annotation value to the output 'operator_iam_role_arn'.
    #
    # For GCP GKE with Workload Identity:
    # 1. Run the terraform module in terraform/gcp/.
    # 2. Set the annotation key to the output 'ksa_annotation_key' (iam.gke.io/gcp-service-account).
    # 3. Set the annotation value to the output 'gcp_service_account_email'.
    #
    # For Azure AKS with Workload Identity:
    # 1. Run the terraform module in terraform/azure/.
    # 2. Set the annotation key to the output 'ksa_annotation_key_client_id' (azure.workload.identity/client-id).
    # 3. Set the annotation value to the output 'operator_identity_client_id'.
    #
    # --- Examples ---
    # AWS:
    #   "eks.amazonaws.com/role-arn": "arn:aws:iam::YOUR_ACCOUNT_ID:role/YOUR_EKS_CLUSTER_NAME-dakr-operator-sa-role"
    # GCP:
    #   "iam.gke.io/gcp-service-account": "your-gcp-sa-email@your-gcp-project-id.iam.gserviceaccount.com"
    # Azure:
    #   "azure.workload.identity/client-id": "YOUR_USER_ASSIGNED_IDENTITY_CLIENT_ID"
    annotations:
      # Replace with the appropriate key-value pair from your Terraform output
      # (see instructions above). 
      "REPLACE_WITH_ANNOTATION_KEY": "REPLACE_WITH_ANNOTATION_VALUE"

scheduler:
  image:
    tag: "v0.0.4"
  nodeCost:
    controlPlaneAddress: "https://dakr.devzero.io"
    controlPlaneToken: "REPLACE_WITH_TOKEN"
    # tokenFromConfigMap: # If clusterToken is not specified above, operator will read from below ConfigMap value
    #   name: "devzero-zxporter-env-config" # Name of the ConfigMap
    #   namespace: "devzero-zxporter"       # Namespace of the ConfigMap
    #   key: "CLUSTER_TOKEN"                # Key in the ConfigMap's data to get the token

agent:
  enabled: false
  nodeImage: dakr-agent
  installerImage: dakr-shim-installer
  criuImage: dakr-criu
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
  runtime: "containerd" # containerd/k3s/rke2
  # control whether to checkpoint and restore kubelet logs (default: false)
  checkpointKubeletLogs: true
  # this is the path to the containerd config file
  # for rke2 it is /var/lib/rancher/rke2/agent/etc/containerd/config.toml
  # for k3s it is /var/lib/rancher/k3s/agent/etc/containerd/config.toml
  # for containerd it is /etc/containerd/config.toml
  containerdConfigPath: "/etc/containerd/config.toml"
  # this is the path to the containerd socket
  # for rke2 it is /run/k3s/containerd/containerd.sock
  # for k3s it is /run/k3s/containerd/containerd.sock
  # for containerd it is /run/containerd/containerd.sock
  containerdSock: "/run/containerd/containerd.sock"
  # disable io_uring on the node to prevent CRIU checkpoint failures
  disableIOUring: false
  # path to the io_uring_disabled sysctl parameter on the host
  ioUringPath: "/host/proc/sys/kernel/io_uring_disabled"
  # configure inotify limits for CRIU checkpoint operations
  configureInotify: true
  # inotify configuration for CRIU
  inotify:
    maxUserInstances: 4096  # Minimum number of inotify instances
    maxUserWatches: 524288  # Minimum number of inotify watches
    instancesPath: "/host/proc/sys/fs/inotify/max_user_instances"  # Path to max_user_instances
    watchesPath: "/host/proc/sys/fs/inotify/max_user_watches"  # Path to max_user_watches

webhook:
  enabled: true
  caBundle: ""  # Base64 encoded CA bundle for webhook

# Runtime Configuration
# Modular tool for configuring container runtimes (containerd, CRI-O, Docker, etc.)
# Includes registry mirror configuration, and can be extended with storage, network, security modules
runtimeConfig:
  enabled: false  # Set to true to enable runtime configuration
  image: dakr-runtime-config

  # Container runtime to configure
  runtime: containerd  # containerd, cri-o (future), docker (future)

  # Runtime-specific paths
  runtimeConfigPath: /etc/containerd/config.toml
  runtimeSocket: /run/containerd/containerd.sock

  # Configuration modules to apply
  # Available modules: registry, storage (future), network (future), security (future)
  modules:
    - registry

  # Timeout for configuration operations
  timeout: 2m

  # Node targeting
  nodeSelector:
    mode: all  # "all" or "labeled"
    # When mode=labeled, specify labels to match
    labels: {}
    # Example:
    # labels:
    #   dakr.devzero.io/runtime-config: "true"

  # Tolerations to allow running on all nodes
  tolerations:
    - effect: NoSchedule
      operator: Exists

  # Registry Mirror Module Configuration
  # Pull-through cache for accelerating image pulls using Zot registry
  # Zot is a lightweight OCI-native registry that can mirror multiple upstream registries
  registryMirrors:
    enabled: false  # Set to true to enable registry mirror deployment

    # Zot-specific configuration
    zot:
      tag: "v2.1.10"  # Zot image tag

    # Service configuration for Zot registry
    service:
      registryPort: 5000
      nodePort: 30500  # Single NodePort for all registries (uses path-based routing)

    # Persistence settings for Zot
    persistence:
      enabled: false  # Set to true to use PersistentVolumes (recommended for production)
      storageClass: ""  # Leave empty to use default storage class
      size: 20Gi  # Total storage size for all cached registries

    # Resource limits for Zot pod
    resources:
      requests:
        cpu: 10m
        memory: 64Mi
      limits:
        cpu: 100m
        memory: 256Mi

    # Registry mirror definitions
    registries:
      # Docker Hub (docker.io)
      - name: dockerhub
        enabled: false
        upstream: "https://registry-1.docker.io"
        ttl: 168h # 7 days
        # These are the registry hostnames that will be mirrored
        mirrorFor:
          - "docker.io"
          - "index.docker.io"
        # credentials:
        #   username: ""
        #   password: ""

      # GitHub Container Registry
      # - name: ghcr
      #   enabled: false
      #   upstream: "https://ghcr.io"
      #   ttl: 168h # 7 days
      #   mirrorFor:
      #     - "ghcr.io"
      #   # credentials:
      #   #   username: ""
      #   #   password: ""

      # Google Container Registry
      # - name: gcr
      #   enabled: false
      #   upstream: "https://gcr.io"
      #   ttl: 168h # 7 days
      #   mirrorFor:
      #     - "gcr.io"
      #   credentials:
      #     username: ""
      #     password: ""

      # Google Artifact Registry
      # - name: gar
      #   enabled: false
      #   upstream: "https://us-docker.pkg.dev"
      #   ttl: 168h # 7 days
      #   mirrorFor:
      #     - "us-docker.pkg.dev"
      #     - "europe-docker.pkg.dev"
      #     - "asia-docker.pkg.dev"
      #   credentials:
      #     username: ""
      #     password: ""

      # Quay.io
      # - name: quay
      #   enabled: false
      #   upstream: "https://quay.io"
      #   ttl: 168h # 7 days
      #   mirrorFor:
      #     - "quay.io"
      #   credentials:
      #     username: ""
      #     password: ""

      # AWS ECR Public
      # - name: ecrpublic
      #   enabled: false
      #   upstream: "https://public.ecr.aws"
      #   ttl: 168h # 7 days
      #   mirrorFor:
      #     - "public.ecr.aws"
      #   credentials:
      #     username: ""
      #     password: ""
