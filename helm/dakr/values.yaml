nameOverride: ""
fullnameOverride: ""

# The cloud provider where the operator is being deployed.
# Must be one of: "aws", "gcp", "azure", or "" (for no cloud provider).
cloud: ""

# Priority Class configuration for critical workloads
# This ensures all DAKR components are not evicted under resource pressure
priorityClass:
  enabled: true  # Enable/disable creation of priority class
  value: 1000000000  # Highest priority value
  preemptionPolicy: PreemptLowerPriority  # Can preempt lower priority pods

image:
  repository: docker.io/devzeroinc
  # This sets the pull policy for images.
  pullPolicy: Always 
  # Overrides the image tag whose default is the chart appVersion.
  tag: "v0.0.42"

imagePullSecrets: []

operator:
  enabled: true
  image: dakr-operator
  replicas: 3
  # Pod Disruption Budget configuration
  podDisruptionBudget:
    enabled: true
    minAvailable: 1  # or use maxUnavailable: 1
    # maxUnavailable: 1  # Alternative to minAvailable
    # unhealthyPodEvictionPolicy: IfHealthyBudget  # Optional: IfHealthyBudget, AlwaysAllow
  # IMPORTANT: When using Secrets for token configuration, note that Secrets cannot be accessed across namespaces.
  # If zxporter is installed in devzero-zxporter namespace by default, you have two options:
  # 1. Install dakr in the same namespace as zxporter (devzero-zxporter)
  # 2. Copy/recreate the Secret from devzero-zxporter namespace to the dakr operator's namespace
  # ConfigMaps can be accessed across namespaces and don't have this limitation.
  resources:
    requests:
      cpu: 10m
      memory: 64Mi
  endpoint: "https://dakr.devzero.io"
  logLevel: "info"
  clusterToken: "" # Required: Authentication token for DAKR control plane. If empty, the operator will attempt to read from Secret or ConfigMap below.
                   # If set to a non-empty string, this value will be used directly.
  clusterName: "" # Required: Unique identifier for this Kubernetes cluster. If empty, the operator will attempt to read from the ConfigMap below.
                  # If set to a non-empty string, this value will be used directly.
  clusterLocation: ""  # Required: Cloud region/zone where the cluster is running (e.g., us-west-2, europe-west1-b)
  # noCloudCreds: true # If true, operator will not attempt to perform node scaling operations, and will not require cloud credentials
  # tokenFromSecret: # If clusterToken is not specified above, operator will read from below Secret value (higher priority than ConfigMap)
  #   name: "devzero-zxporter-token"      # Name of the Secret (must be in the same namespace as the operator)
  #   key: "CLUSTER_TOKEN"                # Key in the Secret's data to get the token
  #   # NOTE: This matches the Secret created by zxporter. Secrets cannot be accessed across namespaces.
  #   # If zxporter is installed in devzero-zxporter namespace and dakr operator is installed in a different namespace,
  #   # the Secret must be recreated in the operator's namespace. Alternatively, install both in the same namespace.
  # tokenFromConfigMap: # If clusterToken is not specified above and not found in Secret, operator will read from below ConfigMap value
  #   name: "devzero-zxporter-env-config" # Name of the ConfigMap
  #   namespace: "devzero-zxporter"       # Namespace of the ConfigMap
  #   key: "CLUSTER_TOKEN"                # Key in the ConfigMap's data to get the token
  # nameFromConfigMap: # If clusterName is not specified above and not found in Secret, operator will read from below ConfigMap value
  #   name: "devzero-zxporter-env-config" # Name of the ConfigMap
  #   namespace: "devzero-zxporter"       # Namespace of the ConfigMap
  #   key: "KUBE_CONTEXT_NAME"            # Key in the ConfigMap's data to get the cluster name from
  customScheduler: false
  port: 9443
  debugPort: 8082
  features:
    argocdPatching: false # if set, the operator will patch argo applications to ignore differences from the dakr operator
    workloadRecBatchSize: 1 # needs to be >=1; determines batch size of pulling down workload recommendations from control plane, before being persisted as CRDs 
    nodeGroupRecBatchSize: 1 # needs to be >=1; determines batch size of pulling down node group recommendations from control plane, before being persisted as CRDs
  # Runtime directories to include in live migration checkpoint operations
  # These directories will be passed to the live migration service for CRIU checkpoint operations
  runtimeDirs: []
  # Janitor configuration for periodic cleanup of old CRDs
  janitor:
    # Cleanup interval in minutes (default: 30)
    cleanupIntervalMinutes: 30
    # Retention period in days for completed/failed/skipped WorkloadRecommendation CRs (default: 7)
    retentionDays: 7
  serviceAccount:
    name: "dakr-operator-sa"
    # Annotations for cloud provider IAM integration.
    #
    # For AWS EKS with IAM Roles for Service Accounts (IRSA):
    # 1. Run the terraform module in terraform/aws/.
    # 2. Set the annotation key to the output 'ksa_annotation_key_aws' (eks.amazonaws.com/role-arn).
    # 3. Set the annotation value to the output 'operator_iam_role_arn'.
    #
    # For GCP GKE with Workload Identity:
    # 1. Run the terraform module in terraform/gcp/.
    # 2. Set the annotation key to the output 'ksa_annotation_key' (iam.gke.io/gcp-service-account).
    # 3. Set the annotation value to the output 'gcp_service_account_email'.
    #
    # For Azure AKS with Workload Identity:
    # 1. Run the terraform module in terraform/azure/.
    # 2. Set the annotation key to the output 'ksa_annotation_key_client_id' (azure.workload.identity/client-id).
    # 3. Set the annotation value to the output 'operator_identity_client_id'.
    #
    # --- Examples ---
    # AWS:
    #   "eks.amazonaws.com/role-arn": "arn:aws:iam::YOUR_ACCOUNT_ID:role/YOUR_EKS_CLUSTER_NAME-dakr-operator-sa-role"
    # GCP:
    #   "iam.gke.io/gcp-service-account": "your-gcp-sa-email@your-gcp-project-id.iam.gserviceaccount.com"
    # Azure:
    #   "azure.workload.identity/client-id": "YOUR_USER_ASSIGNED_IDENTITY_CLIENT_ID"
    annotations: {}
      # Replace with the appropriate key-value pair from your Terraform output
      # (see instructions above).
      # Example for AWS:
      # "eks.amazonaws.com/role-arn": "arn:aws:iam::123456789012:role/cluster-dakr-operator-sa-role"
      # Example for GCP:
      # "iam.gke.io/gcp-service-account": "dakr-operator-sa@project-id.iam.gserviceaccount.com"
      # Example for Azure:
      # "azure.workload.identity/client-id": "12345678-1234-1234-1234-123456789012"

scheduler:
  image:
    tag: "v0.0.6"
  nodeCost:
    controlPlaneAddress: "https://dakr.devzero.io"
    controlPlaneToken: "" # Required: Authentication token for DAKR control plane (same as operator.clusterToken)
    # tokenFromSecret: # If controlPlaneToken is not specified above, scheduler will read from below Secret value (higher priority than ConfigMap)
    #   name: "devzero-zxporter-token"      # Name of the Secret (must be in kube-system namespace where scheduler runs)
    #   key: "CLUSTER_TOKEN"                # Key in the Secret's data to get the token
    #   # NOTE: This matches the Secret created by zxporter (devzero-zxporter-token). Scheduler runs in kube-system namespace.
    #   # If zxporter creates Secret in devzero-zxporter namespace, the Secret must be recreated in kube-system namespace.
    # tokenFromConfigMap: # If controlPlaneToken is not specified above and not found in Secret, scheduler will read from below ConfigMap value
    #   name: "devzero-zxporter-env-config" # Name of the ConfigMap
    #   namespace: "devzero-zxporter"       # Namespace of the ConfigMap
    #   key: "CLUSTER_TOKEN"                # Key in the ConfigMap's data to get the token

agent:
  enabled: false
  nodeImage: dakr-agent
  installerImage: dakr-shim-installer
  criuImage: dakr-criu
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
  runtime: "containerd" # containerd/k3s/rke2
  # control whether to checkpoint and restore kubelet logs (default: false)
  checkpointKubeletLogs: true
  # this is the path to the containerd config file
  # for rke2 it is /var/lib/rancher/rke2/agent/etc/containerd/config.toml
  # for k3s it is /var/lib/rancher/k3s/agent/etc/containerd/config.toml
  # for containerd it is /etc/containerd/config.toml
  containerdConfigPath: "/etc/containerd/config.toml"
  # this is the path to the containerd socket
  # for rke2 it is /run/k3s/containerd/containerd.sock
  # for k3s it is /run/k3s/containerd/containerd.sock
  # for containerd it is /run/containerd/containerd.sock
  containerdSock: "/run/containerd/containerd.sock"
  # disable io_uring on the node to prevent CRIU checkpoint failures
  disableIOUring: false
  # path to the io_uring_disabled sysctl parameter on the host
  ioUringPath: "/host/proc/sys/kernel/io_uring_disabled"
  # configure inotify limits for CRIU checkpoint operations
  configureInotify: true
  # inotify configuration for CRIU
  inotify:
    maxUserInstances: 4096  # Minimum number of inotify instances
    maxUserWatches: 524288  # Minimum number of inotify watches
    instancesPath: "/host/proc/sys/fs/inotify/max_user_instances"  # Path to max_user_instances
    watchesPath: "/host/proc/sys/fs/inotify/max_user_watches"  # Path to max_user_watches

webhook:
  enabled: true
  caBundle: ""  # Base64 encoded CA bundle for webhook

# Runtime Configuration
# Modular tool for configuring container runtimes (containerd, CRI-O, Docker, etc.)
# Includes registry mirror configuration, and can be extended with storage, network, security modules
runtimeConfig:
  enabled: false  # Set to true to enable runtime configuration
  image: dakr-runtime-config

  # Container runtime to configure
  runtime: containerd  # containerd, cri-o (future), docker (future)

  # Runtime-specific paths
  runtimeConfigPath: /etc/containerd/config.toml
  runtimeSocket: /run/containerd/containerd.sock

  # Configuration modules to apply
  # Available modules: registry, storage (future), network (future), security (future)
  modules:
    - registry

  # Timeout for configuration operations
  timeout: 2m

  # Node targeting
  nodeSelector:
    mode: all  # "all" or "labeled"
    # When mode=labeled, specify labels to match
    labels: {}
    # Example:
    # labels:
    #   dakr.devzero.io/runtime-config: "true"

  # Tolerations to allow running on all nodes
  tolerations:
    - effect: NoSchedule
      operator: Exists

  # Registry Mirror Module Configuration
  # Pull-through cache for accelerating image pulls using Zot registry
  # Zot is a lightweight OCI-native registry that can mirror multiple upstream registries
  registryMirrors:
    enabled: false  # Set to true to enable registry mirror deployment

    # Zot-specific configuration
    zot:
      tag: "v2.1.10"  # Zot image tag
      logLevel: "info"  # Log level for Zot registry. Options: debug, info, warn, error

    # Service configuration for Zot registry
    service:
      registryPort: 5000
      nodePort: 30500  # Single NodePort for all registries (uses path-based routing)

    # Persistence settings for Zot
    persistence:
      enabled: false  # Set to true to use PersistentVolumes (recommended for production)
      storageClass: ""  # Leave empty to use default storage class
      size: 20Gi  # Total storage size for all cached registries

    # Resource limits for Zot pod
    resources:
      requests:
        cpu: 10m
        memory: 64Mi
      limits:
        cpu: 100m
        memory: 256Mi

    # Credentials Secret Configuration
    # Credentials are automatically generated from registry credentials below
    # Or you can provide your own secret with credentials.json
    credentialsSecret:
      existingSecret: ""  # Set to use existing secret instead of auto-generated one
      key: "credentials.json"  # Key in the secret containing credentials.json

    # Registry mirror definitions
    registries:
      # Docker Hub (docker.io)
      - name: dockerhub
        enabled: false
        upstream: "https://registry-1.docker.io"
        ttl: "168h" # 7 days
        # These are the registry hostnames that will be mirrored
        mirrorFor:
          - "docker.io"
          - "index.docker.io"
        # credentials:
        #   username: ""
        #   password: ""

      # GitHub Container Registry
      # - name: ghcr
      #   enabled: false
      #   upstream: "https://ghcr.io"
      #   ttl: "168h" # 7 days
      #   mirrorFor:
      #     - "ghcr.io"
      #   # credentials:
      #   #   username: ""
      #   #   password: ""

      # Google Container Registry
      # - name: gcr
      #   enabled: false
      #   upstream: "https://gcr.io"
      #   ttl: "168h" # 7 days
      #   mirrorFor:
      #     - "gcr.io"
      #   credentials:
      #     username: ""
      #     password: ""

      # Google Artifact Registry
      # - name: gar
      #   enabled: false
      #   upstream: "https://us-docker.pkg.dev"
      #   ttl: "168h" # 7 days
      #   mirrorFor:
      #     - "us-docker.pkg.dev"
      #     - "europe-docker.pkg.dev"
      #     - "asia-docker.pkg.dev"
      #   credentials:
      #     username: ""
      #     password: ""

      # Quay.io
      # - name: quay
      #   enabled: false
      #   upstream: "https://quay.io"
      #   ttl: "168h" # 7 days
      #   mirrorFor:
      #     - "quay.io"
      #   credentials:
      #     username: ""
      #     password: ""

      # AWS ECR Public
      # - name: ecrpublic
      #   enabled: false
      #   upstream: "https://public.ecr.aws"
      #   ttl: "168h" # 7 days
      #   mirrorFor:
      #     - "public.ecr.aws"
      #   credentials:
      #     username: ""
      #     password: ""

      # # AWS ECR Private Registry
      # # Uses native credentialHelper for authentication (no username/password needed)
      # - name: ecrprivate
      #   enabled: true
      #   upstream: "https://ACCOUNTID.dkr.ecr.REGION.amazonaws.com"
      #   ttl: "168h"
      #   mirrorFor:
      #     - "https://ACCOUNTID.dkr.ecr.REGION.amazonaws.com"
      #   credentialHelper: "ecr"
